///|
fn int_range(start : Int, end : Int) -> Iterator[Int] {
  let mut i = start
  Iterator::new(fn() {
    if i < end {
      let current = i
      i += 1
      Some(current)
    } else {
      None
    }
  })
}

///|
test "cons" {
  let xs = [] |> @immut_deque.of
  let xs = xs.cons(1).cons(2).cons(3).cons(4).cons(5)
  inspect(xs, content="@deque.of([5, 4, 3, 2, 1])")
}

///|
test "snoc" {
  let xs = [] |> @immut_deque.of
  let xs = xs.snoc(1).snoc(2).snoc(3).snoc(4).snoc(5)
  inspect(xs, content="@deque.of([1, 2, 3, 4, 5])")
}

///|
test "of" {
  let xs = [1, 2, 3, 4, 5] |> @immut_deque.of
  inspect(xs, content="@deque.of([1, 2, 3, 4, 5])")
}

///|
test "cons/snoc" {
  let xs = [] |> @immut_deque.of
  let xs = xs.cons(1).snoc(2).cons(3).snoc(4)
  inspect(xs, content="@deque.of([3, 1, 2, 4])")
}

///|
test "cons/snoc-2" {
  let xs = [1, 2, 3, 4, 5, 6] |> @immut_deque.of
  inspect(xs.cons(99), content="@deque.of([99, 1, 2, 3, 4, 5, 6])")
  inspect(xs.snoc(99), content="@deque.of([1, 2, 3, 4, 5, 6, 99])")
}

///|
test "uncons/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.of([])
  inspect(empty.uncons(), content="None")
}

///|
test "uncons/single" {
  let single = @immut_deque.of([1])
  inspect(single.uncons(), content="Some((1, @deque.of([])))")
}

///|
test "uncons/multiple" {
  let d = @immut_deque.of([1, 2, 3, 4, 5])
  let (head, rest) = d.uncons().unwrap()
  inspect(head, content="1")
  inspect(rest, content="@deque.of([2, 3, 4, 5])")
}

///|
test "unsnoc/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.of([])
  inspect(empty.unsnoc(), content="None")
}

///|
test "unsnoc/single" {
  let d = @immut_deque.of([1])
  inspect(d.unsnoc(), content="Some((1, @deque.of([])))")
}

///|
test "unsnoc/multiple" {
  let d = @immut_deque.of([1, 2, 3])
  inspect(d.unsnoc(), content="Some((3, @deque.of([1, 2])))")
}

///|
test "append" {
  let xs = [] |> @immut_deque.of
  let ys = [] |> @immut_deque.of
  let xs = xs.cons(1).snoc(2)
  let ys = ys.cons(3).snoc(4)
  let zs = xs.append(ys)
  inspect(xs, content="@deque.of([1, 2])")
  inspect(ys, content="@deque.of([3, 4])")
  inspect(zs, content="@deque.of([1, 2, 3, 4])")
}

///|
let xs : @immut_deque.T[Int] = @immut_deque.of([])
  .cons(2)
  .cons(1)
  .snoc(3)
  .snoc(4)

///|
test {
  inspect(xs, content="@deque.of([1, 2, 3, 4])")
}

///|
test "map" {
  inspect(
    xs.map(fn(x) { [x, x * 11] |> @immut_deque.of }),
    content="@deque.of([@deque.of([1, 11]), @deque.of([2, 22]), @deque.of([3, 33]), @deque.of([4, 44])])",
  )
}

///|
test "bind" {
  inspect(
    xs.bind(fn(x) { [x, x * 11] |> @immut_deque.of }),
    content="@deque.of([1, 11, 2, 22, 3, 33, 4, 44])",
  )
}

///|
test "iter/rev_iter" {
  inspect(xs.iter(), content="[1, 2, 3, 4]")
  inspect(xs.rev_iter(), content="[4, 3, 2, 1]")
}

// here is generated by AI

///|
test "@immut_deque.bind/empty" {
  // Test binding an empty deque
  let empty : @immut_deque.T[Int] = @immut_deque.of([])
  let result = empty.bind(fn(x) { @immut_deque.of([x]) })
  inspect(result, content="@deque.of([])")
}

///|
test "@immut_deque.bind/identity" {
  // Test binding with identity function (should preserve structure)
  let d = @immut_deque.of([1, 2, 3])
  let result = d.bind(fn(x) { @immut_deque.of([x]) })
  inspect(result, content="@deque.of([1, 2, 3])")
}

///|
test "@immut_deque.bind/flatten" {
  // Test binding that creates multiple elements
  let d = @immut_deque.of([1, 2])
  let result = d.bind(fn(x) { @immut_deque.of([x, x]) })
  inspect(result, content="@deque.of([1, 1, 2, 2])")
}

///|
test "@immut_deque.join/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.of([])
  let nested_empty = @immut_deque.of([empty])
  inspect(nested_empty.join(), content="@deque.of([])")
}

///|
test "@immut_deque.join/single_level" {
  let d1 = @immut_deque.of([1, 2])
  let d2 = @immut_deque.of([3, 4])
  let nested = @immut_deque.of([d1, d2])
  inspect(nested.join(), content="@deque.of([1, 2, 3, 4])")
}

///|
test "@immut_deque.join/mixed" {
  let d1 = @immut_deque.of([1])
  let d2 = @immut_deque.of([])
  let d3 = @immut_deque.of([2, 3])
  let nested = @immut_deque.of([d1, d2, d3])
  inspect(nested.join(), content="@deque.of([1, 2, 3])")
}

///|
test "@immut_deque.cons/empty" {
  let empty = @immut_deque.empty()
  inspect(@immut_deque.cons(empty, 1), content="@deque.of([1])")
}

///|
test "@immut_deque.cons/single" {
  let single = @immut_deque.of([1])
  inspect(@immut_deque.cons(single, 0), content="@deque.of([0, 1])")
}

///|
test "@immut_deque.cons/multiple" {
  let multiple = @immut_deque.of([1, 2, 3])
  inspect(@immut_deque.cons(multiple, 0), content="@deque.of([0, 1, 2, 3])")
}

///|
test "@immut_deque.append/empty_both" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(@immut_deque.append(empty, empty), content="@deque.of([])")
}

///|
test "@immut_deque.append/empty_left" {
  let empty = @immut_deque.empty()
  let deque = @immut_deque.of([1, 2, 3])
  inspect(@immut_deque.append(empty, deque), content="@deque.of([1, 2, 3])")
}

///|
test "@immut_deque.append/non_empty" {
  let d1 = @immut_deque.of([1, 2])
  let d2 = @immut_deque.of([3, 4])
  inspect(@immut_deque.append(d1, d2), content="@deque.of([1, 2, 3, 4])")
}

///|
test "@immut_deque.snoc/empty" {
  let empty = @immut_deque.empty()
  inspect(@immut_deque.snoc(empty, 1), content="@deque.of([1])")
}

///|
test "@immut_deque.snoc/multiple" {
  let d = @immut_deque.of([1, 2, 3])
  let d1 = @immut_deque.snoc(d, 4)
  let d2 = @immut_deque.snoc(d1, 5)
  inspect(d2, content="@deque.of([1, 2, 3, 4, 5])")
}

///|
test "@immut_deque.snoc/preserve_original" {
  let d = @immut_deque.of([1, 2])
  let _ = @immut_deque.snoc(d, 3)
  inspect(d, content="@deque.of([1, 2])")
}

///|
test "@immut_deque.reverse/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(@immut_deque.reverse(empty), content="@deque.of([])")
}

///|
test "@immut_deque.reverse/single" {
  let single = @immut_deque.of([1])
  inspect(@immut_deque.reverse(single), content="@deque.of([1])")
}

///|
test "@immut_deque.reverse/multiple" {
  let deque = @immut_deque.empty().snoc(4).snoc(5).cons(3).cons(2).cons(1)
  inspect(@immut_deque.reverse(deque), content="@deque.of([5, 4, 3, 2, 1])")
}

///|
test "@immut_deque.uncons/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(empty.uncons(), content="None")
}

///|
test "@immut_deque.uncons/single" {
  let d = @immut_deque.of([1])
  inspect(d.uncons(), content="Some((1, @deque.of([])))")
}

///|
test "@immut_deque.uncons/multiple" {
  let d = @immut_deque.empty().snoc(4).snoc(5).cons(3).cons(2).cons(1)
  let mut curr = d
  let expected = [1, 2, 3, 4, 5]
  for i = 0; i < 5; i = i + 1 {
    match curr.uncons() {
      Some((x, rest)) => {
        inspect(x, content="\{expected[i]}")
        curr = rest
      }
      None => fail("Expected Some but got None at iteration \{i}")
    }
  }
  inspect(curr.unsnoc(), content="None")
}

///|
test "@immut_deque.unsnoc/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(empty.unsnoc(), content="None")
}

///|
test "@immut_deque.unsnoc/single" {
  let d = @immut_deque.of([1])
  let res = d.unsnoc()
  match res {
    Some((x, rest)) => {
      inspect(x, content="1")
      inspect(rest, content="@deque.of([])")
    }
    None => fail("Expected Some but got None")
  }
}

///|
test "@immut_deque.unsnoc/multiple" {
  let d = @immut_deque.empty().snoc(4).snoc(5).cons(3).cons(2).cons(1)
  let mut curr = d
  let expected = [5, 4, 3, 2, 1]
  for i = 0; i < 5; i = i + 1 {
    match curr.unsnoc() {
      Some((x, rest)) => {
        inspect(x, content="\{expected[i]}")
        curr = rest
      }
      None => fail("Expected Some but got None at iteration \{i}")
    }
  }
  inspect(curr.unsnoc(), content="None")
}

///|
test "@immut_deque.map/empty" {
  let empty = @immut_deque.empty()
  let mapped = empty.map(fn(x : Int) { x + 1 })
  inspect(mapped, content="@deque.of([])")
}

///|
test "@immut_deque.map/single_element" {
  let deque = @immut_deque.of([42])
  let mapped = deque.map(fn(x) { x * 2 })
  inspect(mapped, content="@deque.of([84])")
}

///|
test "@immut_deque.map/multiple_elements" {
  let deque = @immut_deque.empty().snoc(4).snoc(5).cons(3).cons(2).cons(1)
  let mapped = deque.map(fn(x) { x * x })
  inspect(mapped, content="@deque.of([1, 4, 9, 16, 25])")
}

///|
test "@immut_deque.foldl/empty" {
  let empty = @immut_deque.empty()
  inspect(@immut_deque.foldl(empty, 0, fn(acc, x) { acc + x }), content="0")
}

///|
test "@immut_deque.foldl/single" {
  let deque = @immut_deque.of([5])
  inspect(@immut_deque.foldl(deque, 0, fn(acc, x) { acc + x }), content="5")
}

///|
test "@immut_deque.foldl/multiple" {
  let deque = @immut_deque.empty().snoc(4).snoc(5).cons(3).cons(2).cons(1)
  // Test sum
  inspect(@immut_deque.foldl(deque, 0, fn(acc, x) { acc + x }), content="15")
  // Test string concatenation
  inspect(
    @immut_deque.foldl(deque, "", fn(acc, x) { acc + x.to_string() }),
    content="12345",
  )
}

///|
test "@immut_deque.foldr/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(@immut_deque.foldr(empty, 0, fn(acc, x) { acc + x }), content="0")
}

///|
test "@immut_deque.foldr/single_element" {
  let d = @immut_deque.of([42])
  inspect(@immut_deque.foldr(d, 0, fn(acc, x) { acc + x }), content="42")
}

///|
test "@immut_deque.foldr/multiple_elements" {
  // Testing right associativity with subtraction
  let d = @immut_deque.of([1, 2, 3])
  // Should compute as: 1 - (2 - (3 - 10)) = 1 - (2 - (-7)) = 1 - 9 = -8
  inspect(@immut_deque.foldr(d, 10, fn(acc, x) { x - acc }), content="-8")
}

///|
fn arbitrary() -> @immut_deque.T[Int] {
  let xs = @quickcheck.samples(100)
  let mut d = @immut_deque.empty()
  for x in xs {
    if x % 2 == 0 {
      d = d.cons(x)
    } else {
      d = d.snoc(x)
    }
  }
  d
}

///|
test "uncons" {
  let d = arbitrary()
  let uncons = []
  let mut uncons_d = d
  while true {
    match uncons_d.uncons() {
      None => break
      Some((x, xs)) => {
        uncons_d = xs
        uncons.push(x)
      }
    }
  }
  inspect(d.to_array() == uncons, content="true")
}

///|
test "unsnoc" {
  let d = arbitrary()
  let uncons = []
  let mut uncons_d = d
  while true {
    match uncons_d.unsnoc() {
      None => break
      Some((x, xs)) => {
        uncons_d = xs
        uncons.push(x)
      }
    }
  }
  inspect(d.rev_iter().to_array() == uncons, content="true")
}

///|
test "@immut_deque.filter/empty" {
  // Test filtering an empty deque should result in an empty deque
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(empty.filter(fn(x) { true }), content="@deque.of([])")
}

///|
test "@immut_deque.filter/all" {
  // Test filtering with a predicate that matches all elements
  let deque = @immut_deque.of([1, 2, 3, 4, 5])
  let all_true = fn(_ : Int) { true }
  inspect(deque.filter(all_true), content="@deque.of([1, 2, 3, 4, 5])")

  // Test filtering with a predicate that matches no elements
  let all_false = fn(_ : Int) { false }
  inspect(deque.filter(all_false), content="@deque.of([])")
}

///|
test "@immut_deque.filter/even_odd" {
  // Test filtering with a more complex predicate
  let deque = @immut_deque.of([1, 2, 3, 4, 5, 6])
  let is_even = fn(x : Int) { x % 2 == 0 }
  inspect(deque.filter(is_even), content="@deque.of([2, 4, 6])")
  let is_odd = fn(x : Int) { not(x % 2 == 0) }
  inspect(deque.filter(is_odd), content="@deque.of([1, 3, 5])")
}

///|
test "@immut_deque.filter_map/empty" {
  let empty = @immut_deque.empty()
  let mapped = empty.filter_map(fn(x : Int) -> Int? { Some(x + 1) })
  inspect(mapped, content="@deque.of([])")
}

///|
test "@immut_deque.filter_map/all_none" {
  let deque = @immut_deque.of([1, 2, 3, 4, 5])
  let mapped = deque.filter_map(fn(_ : Int) -> Int? { None })
  inspect(mapped, content="@deque.of([])")
}

///|
test "@immut_deque.filter_map/mixed" {
  let deque = @immut_deque.of([1, 2, 3, 4, 5])
  let mapped = deque.filter_map(fn(x : Int) -> Int? {
    if x % 2 == 0 {
      Some(x * 2)
    } else {
      None
    }
  })
  inspect(mapped, content="@deque.of([4, 8])")
}

///|
test "@immut_deque.init_/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(@immut_deque.init_(empty), content="@deque.of([])")
}

///|
test "@immut_deque.init_/single" {
  let single = @immut_deque.of([1])
  inspect(@immut_deque.init_(single), content="@deque.of([])")
}

///|
test "@immut_deque.init_/multiple" {
  let multiple = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(@immut_deque.init_(multiple), content="@deque.of([1, 2, 3, 4])")
}

///|
test "@immut_deque.tail/empty" {
  // Test empty deque
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(@immut_deque.tail(empty), content="@deque.of([])")
}

///|
test "@immut_deque.tail/single" {
  // Test deque with single element
  let single = @immut_deque.of([1])
  inspect(@immut_deque.tail(single), content="@deque.of([])")
}

///|
test "@immut_deque.tail/multiple" {
  // Test deque with multiple elements
  let multiple = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(@immut_deque.tail(multiple), content="@deque.of([2, 3, 4, 5])")
}

///|
test "@immut_deque.last/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(empty.last(), content="None")
}

///|
test "@immut_deque.last/single" {
  let d = @immut_deque.of([42])
  inspect(d.last(), content="Some(42)")
}

///|
test "@immut_deque.last/multiple" {
  let d = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(d.last(), content="Some(5)")
}

///|
test "@immut_deque.head/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(empty.head(), content="None")
}

///|
test "@immut_deque.head/single" {
  let xs = @immut_deque.of([42])
  inspect(xs.head(), content="Some(42)")
}

///|
test "@immut_deque.head/multiple" {
  let xs = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(xs.head(), content="Some(1)")
}

///|
test "@immut_deque.take" {
  // Basic functionality: take first n elements
  let deq = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(@immut_deque.take(deq, 3), content="@deque.of([1, 2, 3])")
}

///|
test "@immut_deque.take/empty" {
  // Taking from empty deque should return empty deque
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(@immut_deque.take(empty, 5), content="@deque.of([])")
}

///|
test "@immut_deque.take/overflow" {
  // Taking more elements than available should return all elements
  let deq = @immut_deque.of([1, 2, 3])
  inspect(@immut_deque.take(deq, 100), content="@deque.of([1, 2, 3])")
}

///|
test "@deque.from_iter/empty" {
  let empty_iter : Iterator[Int] = Iterator::empty()
  inspect(@deque.from_iterator(empty_iter), content="@deque.from_array([])")
}

///|
test "@deque.from_iter/single" {
  let single = Iterator::singleton(42)
  inspect(@deque.from_iterator(single), content="@deque.from_array([42])")
}

///|
test "@deque.from_iter/multiple" {
  let arr = [1, 2, 3, 4, 5]
  let iter = arr.iterator()
  inspect(
    @deque.from_iterator(iter),
    content="@deque.from_array([1, 2, 3, 4, 5])",
  )
}

///|
test "@immut_deque.dropWhile/empty" {
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(
    @immut_deque.dropWhile(empty, fn(x) { true }),
    content="@deque.of([])",
  )
}

///|
test "@immut_deque.dropWhile/all" {
  let xs = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(@immut_deque.dropWhile(xs, fn(x) { true }), content="@deque.of([])")
}

///|
test "@immut_deque.dropWhile/none" {
  let xs = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(
    @immut_deque.dropWhile(xs, fn(x) { false }),
    content="@deque.of([1, 2, 3, 4, 5])",
  )
}

///|
test "@immut_deque.drop" {
  // Test dropping nothing from empty deque
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(@immut_deque.drop(empty, 0), content="@deque.of([])")

  // Test dropping nothing from non-empty deque
  let deque = @immut_deque.of([1, 2, 3])
  inspect(@immut_deque.drop(deque, 0), content="@deque.of([1, 2, 3])")

  // Test dropping some elements
  inspect(@immut_deque.drop(deque, 2), content="@deque.of([3])")
}

///|
test "@immut_deque.drop/all" {
  // Test dropping exact number of elements
  let deque = @immut_deque.of([1, 2, 3])
  inspect(@immut_deque.drop(deque, 3), content="@deque.of([])")
}

///|
test "@immut_deque.takeWhile" {
  // Empty deque
  let empty : @immut_deque.T[Int] = @immut_deque.empty()
  inspect(empty.takeWhile(fn(_) { true }), content="@deque.of([])")

  // Take all elements (predicate always true)
  let xs = @immut_deque.of([1, 2, 3, 4, 5])
  inspect(xs.takeWhile(fn(_) { true }), content="@deque.of([1, 2, 3, 4, 5])")

  // Take no elements (predicate always false)
  let ys = @immut_deque.of([1, 2, 3])
  inspect(ys.takeWhile(fn(_) { false }), content="@deque.of([])")
}

///|
test "overflow/@immut/list" {
  let iter = int_range(0, 1 << 20)
  let lst = @list.from_iterator(iter)
  inspect(
    lst.fold(init=0.0, fn(acc, x) { acc + x.to_double() }),
    content="549755289600",
  )
  inspect(
    lst.rev().fold(init=0.0, fn(acc, x) { acc + x.to_double() }),
    content="549755289600",
  )
}

///|
test "overflow" {
  let iter = int_range(0, 1 << 20)
  let deque = @immut_deque.from_iter(iter)
  inspect(
    deque.foldl(0.0, fn(acc, x) { acc + x.to_double() }),
    content="549755289600",
  )
  inspect(
    deque.foldr(0.0, fn(acc, x) { acc + x.to_double() }),
    content="549755289600",
  )
}
